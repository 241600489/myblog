##背景
```
你开发了⼀个游戏，⽇活跃⽤户在10万⼈以上。请设计⼀个活动排⾏榜系统。
在每⽉活动中，玩家得到的活动总分为 0 到 10000 之间的整数。
在每⽉活动结束之后，需要依据这⼀活动总分，从⾼到低为玩家建⽴排⾏榜。
如果多位玩家分数相同，则按得到指定分数顺序排序，先得到的玩家排在前⾯。
系统提供玩家名次查询接⼝，玩家能够查询⾃⼰名次前后10位玩家的分数和名次。
```
##目标
设计一个排行榜拥有以下属性：
1. 支持百万级排行
2. 排序规则为：分数（正序）+获取到指定分数的时间（倒序）
3. 提供 某个玩家名次前、后各10位的玩家
## 方案概述
活动玩家数据存储到数据库里，但关于玩家获取的分数排行存到 
 Redis 的 ZSET 中，member 为该用户唯一标识，score 为分数+获取到指定分数的时间，利用 ZSET 的排序功能实现排行榜

## 详细设计
#### ZSET 里 score 组成
排序的规则有两个
- 用户分数 从大到小
- ”先得到的玩家排在前面“ 即：时间越小越排在前面, 但与 **用户分数** 的相反，因此需要保持一致，时间取反，下面详细说

分数&时间
- 设 uScore 为用户分数 位于0-100000 之间
- 设 gotScoreTime 为用户获取当前分数相关时间
  - a. 由于 Redis 中 ZSET 里的 score 精确到 16 位 ，如果"10000" + 时间（毫秒） 则会超出这个范围，根据需求一个月榜，则只用当前时间与月初的差值即可，一个月的毫秒数为：2592000000 ，"100000" + "2592000000" 正好为16位 满足题意
  - c. 由上规则推出 获得分数时间应该取反 保持和**用户分数**规则相同，因此 gotScoreTime = 一个月的毫秒数-（当前时间 -  月初时间）
  - b. 如果将两个可变的字符串 + 在一起，若需要获取分数时还需要去数据库里查询，因此考虑用位运算把两个数拼接在一起，16位数最大占用  54 bit,  uScore 的最大值 100000 占用 17 bit , gotScoreTime 的最大值为 2592000000 占用 32 bit 因此完全满足，公式如下：
```
long score = uScore << 36 |   gotScoreTime;
long uScore = score >> 36;
long gotScoreTime = uScore << 36 ^ score;
```
因此 'score = uScore << 36 |   gotScoreTime'
### 活动得分增加
当用户完成活动项获取得分时，需要实时把分数更新到 ZSET 中
![活动分数增加流程.png](https://upload-images.jianshu.io/upload_images/11859806-aca212167ab9905e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### 获取用户排名以及前后10位的分数和排名
![获取用户排名以及前后10名](https://upload-images.jianshu.io/upload_images/11859806-75756f528fd48f5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
## 风险以及处理
1. 由于 Redis 是内存式数据库，如果宕机或者重启数据会丢失，解决方法：写程序将 MySQL 里的数据重新加载到 Redis 中 
